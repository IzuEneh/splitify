package controller

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"

	"github.com/gin-gonic/gin"
	m "github.com/splitify/models"
)

type GenerateRequest struct {
	Tracks []m.Track `json:"tracks"`
}

func map2(data []m.Track, f func(int, m.Track) m.Track) []m.Track {

	mapped := make([]m.Track, len(data))

	for i, e := range data {
		mapped[i] = f(i, e)
	}

	return mapped
}

func createNewPlaylist(id int, name string, tracks []m.Track) m.Playlist {
	return m.Playlist{
		ID:          id,
		Images:      []m.Image{{URL: "https://source.unsplash.com/random/60Ã—60/?music", Height: 60, Width: 60}},
		Name:        name,
		Description: "A playlist generated by AI",
		Owner: struct {
			DisplayName string "json:\"display_name\""
		}{"Current User"}, // "Current User"
		Tracks: struct {
			Total int       "json:\"total\""
			Items []m.Track "json:\"items\""
		}{len(tracks), map2(tracks, func(i int, t m.Track) m.Track {
			t.ID = i + 1
			return t
		})}, //len(tracks), tracks
	}
}

func GeneratePlaylists(c *gin.Context) {
	var request GenerateRequest
	if err := c.BindJSON(&request); err != nil {
		return
	}

	hour_in_ms := 1000 * 60 * 60
	time := 0
	updatedPlaylists := []m.Playlist{}
	buffer := []m.Track{}

	for _, track := range request.Tracks {
		if time < hour_in_ms {
			time += track.Track.DurarionMS
			buffer = append(buffer, track)
		} else {
			name := fmt.Sprintf("Playlist %d", len(updatedPlaylists)+1)
			updatedPlaylists = append(updatedPlaylists, createNewPlaylist(len(updatedPlaylists), name, buffer))
			time = track.Track.DurarionMS
			buffer = []m.Track{track}
		}
	}

	if len(buffer) != 0 {
		name := fmt.Sprintf("Playlist %d", len(updatedPlaylists)+1)
		updatedPlaylists = append(updatedPlaylists, createNewPlaylist(len(updatedPlaylists), name, buffer))
	}

	c.IndentedJSON(http.StatusOK, gin.H{"playlists": updatedPlaylists})
}

type SaveRequest struct {
	UserID      string   `json:"user_id"`
	Name        string   `json:"name"`
	Description string   `json:"description"`
	IsPublic    bool     `json:"is_public"`
	Uris        []string `json:"uris"`
}

func savePlaylists(c *gin.Context) {
	println("Saving playlist")
	client := &http.Client{}
	var request SaveRequest
	if err := c.BindJSON(&request); err != nil {
		return
	}

	accessToken := c.Request.Header["Authorization"][0]
	if len(accessToken) == 0 {
		c.AbortWithStatus(http.StatusUnauthorized)
		return
	}

	jsonBytes, err := json.Marshal(map[string]interface{}{
		"name":        request.Name,
		"description": request.Description,
		"public":      request.IsPublic,
	})
	if err != nil {
		fmt.Println("Error")
		c.AbortWithStatus(http.StatusInternalServerError)
		return
	}

	path := fmt.Sprintf("https://api.spotify.com/v1/users/%s/playlists", request.UserID)
	req, err := http.NewRequest(http.MethodPost, path, bytes.NewBuffer(jsonBytes))
	if err != nil {
		fmt.Println("Error creating save request")
		c.AbortWithStatus(http.StatusInternalServerError)
		return
	}

	req.Header.Add("Authorization", accessToken)
	resp, err := client.Do(req)
	if err != nil {
		fmt.Println("Error saving playlist")
		c.AbortWithStatus(http.StatusInternalServerError)
		return
	}

	defer resp.Body.Close()
	body, _ := io.ReadAll(c.Request.Body)
	if resp.StatusCode < 200 || resp.StatusCode > 299 {
		println(string(body))
		fmt.Println("Unable to create playlist")
		c.AbortWithStatus(resp.StatusCode)
		return
	}

	var savedPlaylistResponse interface{}
	err = json.NewDecoder(resp.Body).Decode(&savedPlaylistResponse)
	if err != nil {
		fmt.Println("Unable to decode saved playlist")
		c.AbortWithStatus(resp.StatusCode)
		return
	}

	fmt.Printf("%s", savedPlaylistResponse)
}
